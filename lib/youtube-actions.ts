"use server"

export const runtime = "edge"

export interface YouTubeVideo {
  id: string
  title: string
  description: string
  thumbnails: {
    default: { url: string; width: number; height: number }
    medium: { url: string; width: number; height: number }
    high: { url: string; width: number; height: number }
  }
}

export interface Caption {
  id: string
  language: string
  name: string
  isAutoGenerated: boolean
}

export interface CaptionTrack {
  language: string
  content: string
  format: "srt" | "vtt" | "txt"
}

// YouTube API response types
interface YouTubeVideoSnippet {
  title: string
  description: string
  thumbnails: {
    default: { url: string; width: number; height: number }
    medium: { url: string; width: number; height: number }
    high: { url: string; width: number; height: number }
  }
}

interface YouTubeVideoItem {
  id: string
  snippet: YouTubeVideoSnippet
}

interface YouTubeVideoResponse {
  items: YouTubeVideoItem[]
}

interface YouTubeCaptionItem {
  id: string
  snippet: {
    language: string
    name: string
    trackKind: string
  }
}

interface YouTubeCaptionsResponse {
  items: YouTubeCaptionItem[]
}

/**
 * Extract video ID from various YouTube URL formats
 */
export function extractVideoId(url: string): string | null {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
    /youtube\.com\/watch\?.*v=([^&\n?#]+)/,
    /youtu\.be\/([^&\n?#?]+)/,
    /^([a-zA-Z0-9_-]{11})$/, // Direct video ID
  ]

  // Clean the URL by removing tracking parameters
  const cleanUrl = url.replace(/[?&]si=[^&]*/, "").replace(/[?&]t=[^&]*/, "")

  for (const pattern of patterns) {
    const match = cleanUrl.match(pattern)
    if (match && match[1]) {
      // Extract only the video ID part (first 11 characters for YouTube IDs)
      const videoId = match[1].substring(0, 11)
      if (/^[a-zA-Z0-9_-]{11}$/.test(videoId)) {
        return videoId
      }
    }
  }

  return null
}

/**
 * Validate YouTube URL format
 */
export function isValidYouTubeUrl(url: string): boolean {
  return extractVideoId(url) !== null
}

/**
 * Server action to fetch video information from YouTube API
 */
export async function fetchVideoInfoAction(
  videoId: string,
): Promise<{ success: true; data: YouTubeVideo } | { success: false; error: string }> {
  try {
    console.log("[v0] Fetching video info for ID:", videoId)

    const apiKey = process.env.YOUTUBE_API_KEY
    if (!apiKey) {
      console.log("[v0] YouTube API key not found in environment")
      return { success: false, error: "YouTube API key not configured" }
    }

    const url = `https://www.googleapis.com/youtube/v3/videos?id=${videoId}&part=snippet&key=${apiKey}`
    console.log("[v0] Making request to YouTube API:", url.replace(apiKey, "***"))

    const response = await fetch(url)
    console.log("[v0] YouTube API response status:", response.status)

    if (!response.ok) {
      const errorText = await response.text()
      console.log("[v0] YouTube API error response:", errorText)

      let errorData: { error?: { message?: string } } = {}
      try {
        errorData = JSON.parse(errorText)
      } catch {
        // If JSON parsing fails, use the raw text
      }

      return {
        success: false,
        error: errorData.error?.message || `YouTube API error: ${response.status} - ${errorText}`,
      }
    }

    const data = (await response.json()) as YouTubeVideoResponse
    console.log("[v0] YouTube API response data:", JSON.stringify(data, null, 2))

    if (!data.items || data.items.length === 0) {
      console.log("[v0] No video items found in response")
      return {
        success: false,
        error: "Video not found or is not accessible. Please check if the video is public and the URL is correct.",
      }
    }

    const video = data.items[0]
    console.log("[v0] Successfully found video:", video.snippet.title)

    return {
      success: true,
      data: {
        id: video.id,
        title: video.snippet.title,
        description: video.snippet.description,
        thumbnails: video.snippet.thumbnails,
      },
    }
  } catch (error) {
    console.error("[v0] Error fetching video info:", error)
    return {
      success: false,
      error: `Failed to fetch video information: ${error instanceof Error ? error.message : "Unknown error"}`,
    }
  }
}

/**
 * Server action to fetch available captions for a video
 */
export async function fetchCaptionsAction(
  videoId: string,
): Promise<{ success: true; data: Caption[] } | { success: false; error: string }> {
  try {
    const apiKey = process.env.YOUTUBE_API_KEY
    if (!apiKey) {
      return { success: false, error: "YouTube API key not configured" }
    }

    const url = `https://www.googleapis.com/youtube/v3/captions?videoId=${videoId}&part=snippet&key=${apiKey}`
    const response = await fetch(url)

    if (!response.ok) {
      const errorData = (await response.json()) as { error?: { message?: string } }
      return {
        success: false,
        error: errorData.error?.message || `YouTube API error: ${response.status}`,
      }
    }

    const data = (await response.json()) as YouTubeCaptionsResponse

    const captions: Caption[] = data.items.map((item) => ({
      id: item.id,
      language: item.snippet.language,
      name: item.snippet.name,
      isAutoGenerated: item.snippet.trackKind === "asr",
    }))

    return { success: true, data: captions }
  } catch (error) {
    console.error("Error fetching captions:", error)
    return { success: false, error: "Failed to fetch captions" }
  }
}

/**
 * Server action to download caption track in specified format
 */
export async function downloadCaptionAction(
  videoId: string,
  captionId: string,
  format: "srt" | "vtt" | "txt" = "srt",
): Promise<{ success: true; data: CaptionTrack } | { success: false; error: string }> {
  try {
    const apiKey = process.env.YOUTUBE_API_KEY
    if (!apiKey) {
      return { success: false, error: "YouTube API key not configured" }
    }

    // Download the caption track
    const url = `https://www.googleapis.com/youtube/v3/captions/${captionId}?key=${apiKey}&tfmt=${format}`
    const response = await fetch(url)

    if (!response.ok) {
      const errorData = (await response.json()) as { error?: { message?: string } }
      return {
        success: false,
        error: errorData.error?.message || `YouTube API error: ${response.status}`,
      }
    }

    const content = await response.text()

    // Get language info for the caption
    const captionsResult = await fetchCaptionsAction(videoId)
    if (!captionsResult.success) {
      return { success: false, error: "Failed to get caption language info" }
    }

    const caption = captionsResult.data.find((c) => c.id === captionId)
    const language = caption?.language || "unknown"

    return {
      success: true,
      data: {
        language,
        content,
        format,
      },
    }
  } catch (error) {
    console.error("Error downloading caption:", error)
    return { success: false, error: "Failed to download caption" }
  }
}

/**
 * Convert timestamp to SRT format (HH:MM:SS,mmm)
 */
export function formatSrtTimestamp(seconds: number): string {
  const hours = Math.floor(seconds / 3600)
  const minutes = Math.floor((seconds % 3600) / 60)
  const secs = Math.floor(seconds % 60)
  const milliseconds = Math.floor((seconds % 1) * 1000)

  return `${hours.toString().padStart(2, "0")}:${minutes
    .toString()
    .padStart(2, "0")}:${secs.toString().padStart(2, "0")},${milliseconds.toString().padStart(3, "0")}`
}

/**
 * Convert timestamp to VTT format (HH:MM:SS.mmm)
 */
export function formatVttTimestamp(seconds: number): string {
  const srtFormat = formatSrtTimestamp(seconds)
  return srtFormat.replace(",", ".")
}
