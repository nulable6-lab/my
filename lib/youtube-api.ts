export interface YouTubeVideo {
  id: string
  title: string
  description: string
  thumbnails: {
    default: { url: string; width: number; height: number }
    medium: { url: string; width: number; height: number }
    high: { url: string; width: number; height: number }
  }
}

export interface Caption {
  id: string
  language: string
  name: string
  isAutoGenerated: boolean
}

export interface CaptionTrack {
  language: string
  content: string
  format: "srt" | "vtt" | "txt"
}

/**
 * Extract video ID from various YouTube URL formats
 */
export function extractVideoId(url: string): string | null {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
    /youtube\.com\/watch\?.*v=([^&\n?#]+)/,
    /youtu\.be\/([^&\n?#?]+)/,
    /^([a-zA-Z0-9_-]{11})$/, // Direct video ID
  ]

  // Clean the URL by removing tracking parameters
  const cleanUrl = url.replace(/[?&]si=[^&]*/, "").replace(/[?&]t=[^&]*/, "")

  for (const pattern of patterns) {
    const match = cleanUrl.match(pattern)
    if (match && match[1]) {
      // Extract only the video ID part (first 11 characters for YouTube IDs)
      const videoId = match[1].substring(0, 11)
      if (/^[a-zA-Z0-9_-]{11}$/.test(videoId)) {
        return videoId
      }
    }
  }

  return null
}

/**
 * Validate YouTube URL format
 */
export function isValidYouTubeUrl(url: string): boolean {
  return extractVideoId(url) !== null
}

/**
 * Fetch video information from YouTube API
 */
export async function fetchVideoInfo(videoId: string): Promise<YouTubeVideo | null> {
  try {
    console.log("[v0] Fetching video info for:", videoId)
    const response = await fetch(`/api/youtube/video?id=${videoId}`)

    if (!response.ok) {
      const errorData = (await response.json()) as { error?: string }
      console.error("[v0] API error:", errorData)
      throw new Error(errorData.error || "Failed to fetch video info")
    }

    const data = await response.json()
    console.log("[v0] Successfully fetched video:", data.title)
    return data
  } catch (error) {
    console.error("[v0] Error fetching video info:", error)
    return null
  }
}

/**
 * Fetch available captions for a video
 */
export async function fetchCaptions(videoId: string): Promise<Caption[]> {
  try {
    const response = await fetch(`/api/youtube/captions?id=${videoId}`)
    if (!response.ok) {
      throw new Error("Failed to fetch captions")
    }
    return await response.json()
  } catch (error) {
    console.error("Error fetching captions:", error)
    return []
  }
}

/**
 * Download caption track in specified format
 */
export async function downloadCaption(
  videoId: string,
  captionId: string,
  format: "srt" | "vtt" | "txt" = "srt",
): Promise<CaptionTrack | null> {
  try {
    const response = await fetch(`/api/youtube/download-caption`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ videoId, captionId, format }),
    })

    if (!response.ok) {
      throw new Error("Failed to download caption")
    }

    return await response.json()
  } catch (error) {
    console.error("Error downloading caption:", error)
    return null
  }
}

/**
 * Convert timestamp to SRT format (HH:MM:SS,mmm)
 */
export function formatSrtTimestamp(seconds: number): string {
  const hours = Math.floor(seconds / 3600)
  const minutes = Math.floor((seconds % 3600) / 60)
  const secs = Math.floor(seconds % 60)
  const milliseconds = Math.floor((seconds % 1) * 1000)

  return `${hours.toString().padStart(2, "0")}:${minutes
    .toString()
    .padStart(2, "0")}:${secs.toString().padStart(2, "0")},${milliseconds.toString().padStart(3, "0")}`
}

/**
 * Convert timestamp to VTT format (HH:MM:SS.mmm)
 */
export function formatVttTimestamp(seconds: number): string {
  const srtFormat = formatSrtTimestamp(seconds)
  return srtFormat.replace(",", ".")
}
